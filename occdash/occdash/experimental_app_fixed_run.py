import json
import logging
import os
from pathlib import Path

import dash
import dash_core_components as dcc
import dash_html_components as html
import networkx
import networkx as nx
from dash.dependencies import Input, Output
from flask_caching import Cache

import occ.reduction
import occ.reduction.occasion_graph
import occ.sim
from occ.sim import SimulationResult
import occ.vis.analysis
import occ.vis.network_dash
import occ.vis.occasion_graph
import occdash
from occ.reduction import read
from pyspike.sacred.sacredrun import SacredRun

# RUN_180 = SacredRun(Path(occdash.__file__).parent.parent / 'tests' / 'files' / 'run_180')


logging.basicConfig(level=logging.DEBUG)


TEST_MODE = True  # TODO: disable!

if TEST_MODE:
    RUN_PATH_BASE = Path(occdash.__file__).parent.parent / 'tests' / 'files'
else:
    RUN_PATH_BASE = Path('/Users/walton/Documents/DPhil/code/occmodeller/runs')


def load_medium_graph(medium_gml_path: Path):
    return nx.read_gml(str(medium_gml_path), destringizer=int)


# external_stylesheets = ['https://codepen.io/chriddyp/pen/bWLwgP.css']
#
# styles = {
#     'pre': {
#         'border': 'thin lightgrey solid',
#         'overflowX': 'scroll'
#     }
# }

# CACHE_CONFIG = {
#     # try 'filesystem' if you don't want to setup redis
#     # 'CACHE_TYPE': 'filesystem',
#     # 'CACHE_DIR': '/Users/walton/Documents/DPhil/proof-of-concept/flask_cache',
#     'CACHE_TYPE': 'redis',
#     'CACHE_REDIS_URL': os.environ.get('REDIS_URL', 'localhost:6379')
# }


def create_dash_app(simulation_result):
    app = dash.Dash(__name__)

    app.layout = html.Div('Hello World')
    return app

    place_changes = occ.reduction.occasion_graph.filter_place_changed_events(
        simulation_result.places)
    place_changes.sort_values('tstep')

    places_with_non_coloured_sums = occ.reduction.tidy_places(
        simulation_result.raw_places, drop_non_coloured_sums=False)

    def create_network_graph_slider():
        unique_times = place_changes['time'].unique()
        dct = {t: '' for t in unique_times}
        # label the first and last only (or they overlap)
        dct[unique_times[0]] = str(unique_times[0])
        dct[unique_times[-1]] = str(unique_times[-1])

        return dcc.Slider(
            id='network-graph-slider',
            min=unique_times[0],
            max=unique_times[-1],
            step=None,
            marks=dct,
            value=unique_times[0],
            updatemode='drag',
        )

    def create_place_count_graph():
        return occ.vis.analysis.generate_sums_by_state_figure(places=places_with_non_coloured_sums)

    def create_occasion_graph_graph():
        tstep = simulation_result.sim_args.step
        places = simulation_result.places  # read.read_tidy_csv(filename=str(run.places_path), node_type="place", drop_non_coloured_sums=True)
        transitions = simulation_result.transitions  # read.read_tidy_csv(filename=str(run.transitions_path), node_type="transition", drop_non_coloured_sums=True)

        place_change_events = occ.reduction.occasion_graph.generate_place_increased_events(places)
        transition_events = occ.reduction.occasion_graph.generate_transition_events(transitions)

        occasion_graph = occ.reduction.occasion_graph.generate_causal_graph(
            place_change_events, transition_events, time_per_step=tstep)

        return occ.vis.occasion_graph.generate_causal_graph_figure(
            occasion_graph, simulation_result.model.network)

    ####

    app = dash.Dash(__name__)  # , external_stylesheets=external_stylesheets)
    # cache = Cache()
    # cache.init_app(app.server, config=CACHE_CONFIG)
    # We are assigning callbacks to components that are generated by other callbacks
    # This requires:
    app.config['suppress_callback_exceptions'] = True

    app.layout = html.Div([

        html.Div(
            dcc.Graph(
                id='occasion-graph-graph',
                figure=create_occasion_graph_graph(),
                style={'width': '800', 'height': '800'}
            ),
            style={'display': 'inline-block'}
        ),
        html.Div([
            dcc.Graph(
                figure=create_place_count_graph(),
                id='place-count-graph',
                style={'width': '400'},
            ),
            dcc.Graph(
                id='network-graph',
                style={'width': '400'}
            ),
            html.Div(
                create_network_graph_slider(),
                id='network-graph-slider-keeper'
            )

            ],
            style={'display': 'inline-block'}
        ),

        # html.Div(
        #     id='run-info',
        # ),

    ])

    @app.callback(Output('network-graph', 'figure'),
                  [Input('network-graph-slider', 'value')])
    def update_network_graph(t):
        logging.info(f'Updating network-graph for t: {t}')

        changed_places_dropped = place_changes.dropna()
        sr = simulation_result
        figure = occ.vis.network_dash.generate_network_figure(
            changed_places_dropped, sr.model.network, sr.sim_args, t)
        return figure

    return app

    #########


    # @app.callback(
    #     Output('occasion-graph-graph', 'figure'),
    #     [Input('place-count-graph', 'relayoutData')],
    #     [State('occasion-graph-graph', 'figure')])
    def update_causal_graph_range(relayout_data, occ_graph):
        if relayout_data and ('xaxis.range' in relayout_data):
            t_min, t_max = relayout_data['xaxis.range']
        elif relayout_data and ('xaxis.range[0]' in relayout_data):
            t_min = relayout_data['xaxis.range[0]']
            t_max = relayout_data['xaxis.range[1]']
        else:
            return occ_graph

        occ_graph['layout']['scene']['zaxis']['autorange'] = False
        occ_graph['layout']['scene']['zaxis']['range'] = (t_min, t_max)
        return occ_graph
        # return json.dumps(relayout_data, indent=2)


# @app.callback(Output('occasion-graph-graph', 'figure'),
#               [Input('run-id', 'data')])
# def update_occasion_graph_graph(run_id):
#     if run_id is None:
#         return None
#
#     run = sacred_run(run_id)
#     tstep = run.config['spike']['sim_args']['interval']['step']
#     changed_places = changed_places_df(run_id)
#
#     # non coloured sums must be dropped before filtering out on change events
#     # (so cannot use the existing changed_places_df() function)
#     # TODO: if this fixes it then move out into a memoizable functin
#     # TODO: update it turns out that this is not
#     places = places_df(run_id)
#     changed_places.dropna(inplace=True)
#     place_changes = temporal.filter_place_changed_events(places)
#     place_changes.sort_values('tstep')
#
#     transitions = tidydata.read_csv(filename=str(run.transitions_path), node_type="transition", drop_non_coloured_sums=True)
#     transitions = pyspike.tidydata.prepend_tidy_frame_with_tstep(transitions)
#     transition_events = pyspike.temporal.generate_transition_events(transitions)
#
#     occasion_graph = pyspike.temporal.generate_causal_graph(
#         changed_places, transition_events, time_per_step=tstep)
#
#     return pyspike.temporal.generate_causal_graph_figure(
#         occasion_graph, medium_graph(run_id))

########


#####


#
#
# @cache.memoize()
# def medium_graph(run_id):
#     run = sacred_run(run_id)
#     return load_medium_graph(run.medium_graph_path)
#     # return graph_to_json(g)

#####

def run_path(run_id):
    return RUN_PATH_BASE / str(run_id)


def graph_to_json(g: nx.Graph):
    data = networkx.readwrite.json_graph.node_link_data(g)
    return json.dumps(data)


def json_to_graph(s: str):
    data = json.loads(s)
    return networkx.readwrite.json_graph.node_link_graph(data)


# dcc.Markdown('''
#
# #### Todo
#
# - Check all old features working
# - Add cache
# - Create a table showing run info
# - Make the big grap take 800 wide and stack other 2
#
#
# #### Feature ideas
#
# - Create a link that zooms into the big graph
# - Allow selection of nodes in the network graph to filer those shown in causal graph
# - Animate movie button
# - Export state at time button
# - DIAMOND - show that multiple open windows may interact.
#
# #### Done
#
# ****
#
# #### Simulation side
# [ ] Use exported state
#
#
# #### Tips
#
#
# Dash supports [Markdown](http://commonmark.org/help).
#
# Markdown is a simple way to write and format text.
# It includes a syntax for things like **bold text** and *italics*,
# [links](http://commonmark.org/help), inline `code` snippets, lists,
# quotes, and more.
#     ''')

if __name__ == '__main__':
    simulation_result = occ.sim.load(run_path(180))
    _app = create_dash_app(simulation_result)
    _app.run_server(debug=True)
